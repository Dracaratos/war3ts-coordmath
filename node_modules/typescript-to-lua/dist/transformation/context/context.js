"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const CompilerOptions_1 = require("../../CompilerOptions");
const lua_ast_1 = require("../utils/lua-ast");
class TransformationContext {
    constructor(program, sourceFile, visitorMap) {
        var _a, _b, _c;
        this.program = program;
        this.sourceFile = sourceFile;
        this.visitorMap = visitorMap;
        this.checker = this
            .program.getDiagnosticsProducingTypeChecker();
        this.options = this.program.getCompilerOptions();
        this.luaTarget = (_a = this.options.luaTarget, (_a !== null && _a !== void 0 ? _a : CompilerOptions_1.LuaTarget.LuaJIT));
        this.isModule = ts.isExternalModule(this.sourceFile);
        this.isStrict = (_b = this.options.alwaysStrict, (_b !== null && _b !== void 0 ? _b : this.options.strict)) ||
            (this.isModule && this.options.target !== undefined && this.options.target >= ts.ScriptTarget.ES2015);
        this.currentNodeVisitors = [];
        // Use `getParseTreeNode` to get original SourceFile node, before it was substituted by custom transformers.
        // It's required because otherwise `getEmitResolver` won't use cached diagnostics, produced in `emitWorker`
        // and would try to re-analyze the file, which would fail because of replaced nodes.
        const originalSourceFile = (_c = ts.getParseTreeNode(sourceFile, ts.isSourceFile), (_c !== null && _c !== void 0 ? _c : sourceFile));
        this.resolver = this.checker.getEmitResolver(originalSourceFile);
    }
    transformNode(node) {
        var _a;
        // TODO: Move to visitors?
        if ((_a = node.modifiers) === null || _a === void 0 ? void 0 : _a.some(modifier => modifier.kind === ts.SyntaxKind.DeclareKeyword)) {
            return [];
        }
        const nodeVisitors = this.visitorMap.get(node.kind);
        if (!nodeVisitors || nodeVisitors.length === 0) {
            throw new Error(`${ts.SyntaxKind[node.kind]} is not supported`);
        }
        const previousNodeVisitors = this.currentNodeVisitors;
        this.currentNodeVisitors = [...nodeVisitors];
        const visitor = this.currentNodeVisitors.pop();
        const result = lua_ast_1.unwrapVisitorResult(visitor.transform(node, this));
        this.currentNodeVisitors = previousNodeVisitors;
        return result;
    }
    superTransformNode(node) {
        if (this.currentNodeVisitors.length === 0) {
            throw new Error(`There is no super transform for ${ts.SyntaxKind[node.kind]} visitor`);
        }
        const visitor = this.currentNodeVisitors.pop();
        return lua_ast_1.unwrapVisitorResult(visitor.transform(node, this));
    }
    transformExpression(node) {
        const [result] = this.transformNode(node);
        return result;
    }
    superTransformExpression(node) {
        const [result] = this.superTransformNode(node);
        return result;
    }
    transformStatements(node) {
        return Array.isArray(node)
            ? node.flatMap(n => this.transformStatements(n))
            : // TODO: https://github.com/microsoft/TypeScript/pull/28916
                this.transformNode(node);
    }
    superTransformStatements(node) {
        return Array.isArray(node)
            ? node.flatMap(n => this.superTransformStatements(n))
            : // TODO: https://github.com/microsoft/TypeScript/pull/28916
                this.superTransformNode(node);
    }
}
exports.TransformationContext = TransformationContext;
//# sourceMappingURL=context.js.map
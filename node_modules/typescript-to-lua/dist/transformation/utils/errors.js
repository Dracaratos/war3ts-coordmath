"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const CompilerOptions_1 = require("../../CompilerOptions");
class TranspileError extends Error {
    constructor(message, node) {
        super(message);
        this.node = node;
        this.name = "TranspileError";
    }
}
exports.TranspileError = TranspileError;
const getLuaTargetName = (version) => (version === CompilerOptions_1.LuaTarget.LuaJIT ? "LuaJIT" : `Lua ${version}`);
exports.ForbiddenForIn = (node) => new TranspileError(`Iterating over arrays with 'for ... in' is not allowed.`, node);
exports.ForbiddenLuaTableNonDeclaration = (node) => new TranspileError(`Classes with the '@luaTable' annotation must be declared.`, node);
exports.InvalidExtendsLuaTable = (node) => new TranspileError(`Cannot extend classes with the '@luaTable' annotation.`, node);
exports.InvalidInstanceOfLuaTable = (node) => new TranspileError(`The instanceof operator cannot be used with a '@luaTable' class.`, node);
exports.ForbiddenLuaTableUseException = (description, node) => new TranspileError(`Invalid @luaTable usage: ${description}`, node);
exports.InvalidAnnotationArgumentNumber = (name, got, expected, node) => new TranspileError(`'${name}' expects ${expected} argument(s) but got ${got}.`, node);
exports.InvalidDecoratorContext = (node) => new TranspileError(`Decorator function cannot have 'this: void'.`, node);
exports.InvalidExtensionMetaExtension = (node) => new TranspileError(`Cannot use both '@extension' and '@metaExtension' annotations on the same class.`, node);
exports.InvalidNewExpressionOnExtension = (node) => new TranspileError(`Cannot construct classes with '@extension' or '@metaExtension' annotation.`, node);
exports.InvalidExportDeclaration = (declaration) => new TranspileError("Encountered invalid export declaration without exports and without module.", declaration);
exports.InvalidExtendsExtension = (node) => new TranspileError(`Cannot extend classes with '@extension' or '@metaExtension' annotation.`, node);
exports.InvalidExportsExtension = (node) => new TranspileError(`Cannot export classes with '@extension' or '@metaExtension' annotation.`, node);
exports.InvalidInstanceOfExtension = (node) => new TranspileError(`Cannot use instanceof on classes with '@extension' or '@metaExtension' annotation.`, node);
exports.InvalidJsonFileContent = (node) => new TranspileError("Invalid JSON file content", node);
exports.MissingClassName = (node) => new TranspileError(`Class declarations must have a name.`, node);
exports.MissingForOfVariables = (node) => new TranspileError("Transpiled ForOf variable declaration list contains no declarations.", node);
exports.MissingFunctionName = (declaration) => new TranspileError("Unsupported function declaration without name.", declaration);
exports.MissingMetaExtension = (node) => new TranspileError(`'@metaExtension' annotation requires the extension of the metatable class.`, node);
exports.NonFlattenableDestructure = (node) => new TranspileError(`This node cannot be destructured using a standard Lua assignment statement.`, node);
exports.UndefinedFunctionDefinition = (functionSymbolId) => new Error(`Function definition for function symbol ${functionSymbolId} is undefined.`);
exports.UnsupportedForInVariable = (node) => new TranspileError(`Unsupported for-in variable kind.`, node);
exports.UndefinedScope = () => new Error("Expected to pop a scope, but found undefined.");
exports.UndefinedTypeNode = (node) => new TranspileError("Failed to resolve required type node.", node);
exports.UnknownSuperType = (node) => new TranspileError("Unable to resolve type of super expression.", node);
exports.UnsupportedImportType = (node) => new TranspileError(`Unsupported import type.`, node);
exports.UnsupportedKind = (description, kind, node) => new TranspileError(`Unsupported ${description} kind: ${ts.SyntaxKind[kind]}`, node);
exports.UnsupportedProperty = (parentName, property, node) => new TranspileError(`Unsupported property on ${parentName}: ${property}`, node);
exports.UnsupportedForTarget = (functionality, version, node) => new TranspileError(`${functionality} is/are not supported for target ${getLuaTargetName(version)}.`, node);
exports.UnsupportedFunctionWithoutBody = (node) => new TranspileError("Functions with undefined bodies are not supported.", node);
exports.UnsupportedNoSelfFunctionConversion = (node, name) => {
    const nameReference = name ? ` '${name}'` : "";
    return new TranspileError(`Unable to convert function with a 'this' parameter to function${nameReference} with no 'this'. ` +
        `To fix, wrap in an arrow function, or declare with 'this: void'.`, node);
};
exports.UnsupportedSelfFunctionConversion = (node, name) => {
    const nameReference = name ? ` '${name}'` : "";
    return new TranspileError(`Unable to convert function with no 'this' parameter to function${nameReference} with 'this'. ` +
        `To fix, wrap in an arrow function or declare with 'this: any'.`, node);
};
exports.UnsupportedOverloadAssignment = (node, name) => {
    const nameReference = name ? ` to '${name}'` : "";
    return new TranspileError(`Unsupported assignment of function with different overloaded types for 'this'${nameReference}. ` +
        "Overloads should all have the same type for 'this'.", node);
};
exports.UnsupportedNonDestructuringLuaIterator = (node) => new TranspileError("Unsupported use of lua iterator with '@tupleReturn' annotation in for...of statement. " +
    "You must use a destructuring statement to catch results from a lua iterator with " +
    "the '@tupleReturn' annotation.", node);
exports.UnresolvableRequirePath = (node, reason, path) => new TranspileError(`${reason}. TypeScript path: ${path}.`, node);
exports.ReferencedBeforeDeclaration = (node) => new TranspileError(`Identifier "${node.text}" was referenced before it was declared. The declaration ` +
    "must be moved before the identifier's use, or hoisting must be enabled.", node);
exports.UnsupportedObjectDestructuringInForOf = (node) => new TranspileError(`Unsupported object destructuring in for...of statement.`, node);
exports.InvalidAmbientIdentifierName = (node) => new TranspileError(`Invalid ambient identifier name "${node.text}". Ambient identifiers must be valid lua identifiers.`, node);
exports.InvalidForRangeCall = (node, message) => new TranspileError(`Invalid @forRange call: ${message}`, node);
exports.UnsupportedVarDeclaration = (node) => new TranspileError("`var` declarations are not supported. Use `let` or `const` instead.", node);
//# sourceMappingURL=errors.js.map
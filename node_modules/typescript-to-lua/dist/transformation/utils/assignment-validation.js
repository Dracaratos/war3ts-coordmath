"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const utils_1 = require("../../utils");
const annotations_1 = require("./annotations");
const errors_1 = require("./errors");
const function_context_1 = require("./function-context");
// TODO: Make validateAssignment check symbols?
// TODO: Move to LuaTable plugin?
function validatePropertyAssignment(context, node) {
    if (!ts.isPropertyAccessExpression(node.left))
        return;
    const leftType = context.checker.getTypeAtLocation(node.left.expression);
    const annotations = annotations_1.getTypeAnnotations(leftType);
    if (annotations.has(annotations_1.AnnotationKind.LuaTable) && node.left.name.text === "length") {
        throw errors_1.ForbiddenLuaTableUseException(`A LuaTable object's length cannot be re-assigned.`, node);
    }
}
exports.validatePropertyAssignment = validatePropertyAssignment;
// TODO: Clear if types are reused between compilations
const typeValidationCache = new WeakMap();
function validateAssignment(context, node, fromType, toType, toName) {
    if (toType === fromType) {
        return;
    }
    if ((toType.flags & ts.TypeFlags.Any) !== 0) {
        // Assigning to un-typed variable
        return;
    }
    // Use cache to avoid repeating check for same types (protects against infinite loop in recursive types)
    const fromTypeCache = utils_1.getOrUpdate(typeValidationCache, fromType, () => new Set());
    if (fromTypeCache.has(toType))
        return;
    fromTypeCache.add(toType);
    validateFunctionAssignment(context, node, fromType, toType, toName);
    const fromTypeNode = context.checker.typeToTypeNode(fromType);
    const toTypeNode = context.checker.typeToTypeNode(toType);
    if (!fromTypeNode || !toTypeNode) {
        return;
    }
    if ((ts.isArrayTypeNode(toTypeNode) || ts.isTupleTypeNode(toTypeNode)) &&
        (ts.isArrayTypeNode(fromTypeNode) || ts.isTupleTypeNode(fromTypeNode))) {
        // Recurse into arrays/tuples
        const fromTypeArguments = fromType.typeArguments;
        const toTypeArguments = toType.typeArguments;
        if (fromTypeArguments === undefined || toTypeArguments === undefined) {
            return;
        }
        const count = Math.min(fromTypeArguments.length, toTypeArguments.length);
        for (let i = 0; i < count; ++i) {
            validateAssignment(context, node, fromTypeArguments[i], toTypeArguments[i], toName);
        }
    }
    if ((toType.flags & ts.TypeFlags.Object) !== 0 &&
        (toType.objectFlags & ts.ObjectFlags.ClassOrInterface) !== 0 &&
        toType.symbol &&
        toType.symbol.members &&
        fromType.symbol &&
        fromType.symbol.members) {
        // Recurse into interfaces
        toType.symbol.members.forEach((toMember, memberName) => {
            if (fromType.symbol.members) {
                const fromMember = fromType.symbol.members.get(memberName);
                if (fromMember) {
                    const toMemberType = context.checker.getTypeOfSymbolAtLocation(toMember, node);
                    const fromMemberType = context.checker.getTypeOfSymbolAtLocation(fromMember, node);
                    validateAssignment(context, node, fromMemberType, toMemberType, toName ? `${toName}.${memberName}` : memberName.toString());
                }
            }
        });
    }
}
exports.validateAssignment = validateAssignment;
function validateFunctionAssignment(context, node, fromType, toType, toName) {
    const fromContext = function_context_1.getFunctionContextType(context, fromType);
    const toContext = function_context_1.getFunctionContextType(context, toType);
    if (fromContext === function_context_1.ContextType.Mixed || toContext === function_context_1.ContextType.Mixed) {
        throw errors_1.UnsupportedOverloadAssignment(node, toName);
    }
    else if (fromContext !== toContext && fromContext !== function_context_1.ContextType.None && toContext !== function_context_1.ContextType.None) {
        if (toContext === function_context_1.ContextType.Void) {
            throw errors_1.UnsupportedNoSelfFunctionConversion(node, toName);
        }
        else {
            throw errors_1.UnsupportedSelfFunctionConversion(node, toName);
        }
    }
}
//# sourceMappingURL=assignment-validation.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./errors");
const typescript_1 = require("./typescript");
const export_1 = require("./export");
exports.luaKeywords = new Set([
    "and",
    "break",
    "do",
    "else",
    "elseif",
    "end",
    "false",
    "for",
    "function",
    "goto",
    "if",
    "in",
    "local",
    "nil",
    "not",
    "or",
    "repeat",
    "return",
    "then",
    "true",
    "until",
    "while",
]);
exports.luaBuiltins = new Set([
    "_G",
    "assert",
    "coroutine",
    "debug",
    "error",
    "ipairs",
    "math",
    "pairs",
    "pcall",
    "print",
    "rawget",
    "rawset",
    "repeat",
    "require",
    "self",
    "string",
    "table",
    "tostring",
    "type",
    "unpack",
]);
exports.isValidLuaIdentifier = (str) => /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(str);
exports.isUnsafeName = (name) => exports.luaKeywords.has(name) || exports.luaBuiltins.has(name) || !exports.isValidLuaIdentifier(name);
function hasUnsafeSymbolName(context, symbol, tsOriginal) {
    const isLuaKeyword = exports.luaKeywords.has(symbol.name);
    const isInvalidIdentifier = !exports.isValidLuaIdentifier(symbol.name);
    const isAmbient = symbol.declarations && symbol.declarations.some(d => typescript_1.isAmbientNode(d));
    if ((isLuaKeyword || isInvalidIdentifier) && isAmbient) {
        // Catch ambient declarations of identifiers with bad names
        throw errors_1.InvalidAmbientIdentifierName(tsOriginal);
    }
    if (exports.isUnsafeName(symbol.name)) {
        // only unsafe when non-ambient and not exported
        return !isAmbient && !export_1.isSymbolExported(context, symbol);
    }
    return false;
}
exports.hasUnsafeSymbolName = hasUnsafeSymbolName;
function hasUnsafeIdentifierName(context, identifier) {
    const symbol = context.checker.getSymbolAtLocation(identifier);
    if (symbol !== undefined) {
        return hasUnsafeSymbolName(context, symbol, identifier);
    }
    else if (exports.luaKeywords.has(identifier.text) || !exports.isValidLuaIdentifier(identifier.text)) {
        throw errors_1.InvalidAmbientIdentifierName(identifier);
    }
    return false;
}
exports.hasUnsafeIdentifierName = hasUnsafeIdentifierName;
const fixInvalidLuaIdentifier = (name) => name.replace(/[^a-zA-Z0-9_]/g, c => `_${c
    .charCodeAt(0)
    .toString(16)
    .toUpperCase()}`);
exports.createSafeName = (name) => "____" + fixInvalidLuaIdentifier(name);
//# sourceMappingURL=safe-names.js.map
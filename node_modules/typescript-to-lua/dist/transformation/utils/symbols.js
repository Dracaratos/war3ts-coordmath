"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils");
const errors_1 = require("./errors");
const scope_1 = require("./scope");
const typescript_1 = require("./typescript");
const symbolIdCounters = new WeakMap();
function nextSymbolId(context) {
    var _a;
    const symbolId = (_a = symbolIdCounters.get(context), (_a !== null && _a !== void 0 ? _a : 0)) + 1;
    symbolIdCounters.set(context, symbolId);
    return symbolId;
}
const symbolInfoMap = new WeakMap();
const symbolIdMaps = new WeakMap();
function getSymbolInfo(context, symbolId) {
    return utils_1.getOrUpdate(symbolInfoMap, context, () => new Map()).get(symbolId);
}
exports.getSymbolInfo = getSymbolInfo;
function getSymbolIdOfSymbol(context, symbol) {
    return utils_1.getOrUpdate(symbolIdMaps, context, () => new Map()).get(symbol);
}
exports.getSymbolIdOfSymbol = getSymbolIdOfSymbol;
function trackSymbolReference(context, symbol, identifier) {
    const symbolIds = utils_1.getOrUpdate(symbolIdMaps, context, () => new Map());
    // Track first time symbols are seen
    let symbolId = symbolIds.get(symbol);
    if (symbolId === undefined) {
        symbolId = nextSymbolId(context);
        symbolIds.set(symbol, symbolId);
        const symbolInfo = utils_1.getOrUpdate(symbolInfoMap, context, () => new Map());
        symbolInfo.set(symbolId, { symbol, firstSeenAtPos: identifier.pos });
    }
    if (context.options.noHoisting) {
        // Check for reference-before-declaration
        const declaration = typescript_1.getFirstDeclarationInFile(symbol, context.sourceFile);
        if (declaration && identifier.pos < declaration.pos) {
            throw errors_1.ReferencedBeforeDeclaration(identifier);
        }
    }
    scope_1.markSymbolAsReferencedInCurrentScopes(context, symbolId, identifier);
    return symbolId;
}
exports.trackSymbolReference = trackSymbolReference;
function getIdentifierSymbolId(context, identifier) {
    const symbol = context.checker.getSymbolAtLocation(identifier);
    if (symbol) {
        return trackSymbolReference(context, symbol, identifier);
    }
}
exports.getIdentifierSymbolId = getIdentifierSymbolId;
//# sourceMappingURL=symbols.js.map
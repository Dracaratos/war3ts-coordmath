"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../utils/errors");
const function_context_1 = require("../utils/function-context");
const lualib_1 = require("../utils/lualib");
const call_1 = require("../visitors/call");
function transformFunctionPrototypeCall(context, node) {
    const expression = node.expression;
    const callerType = context.checker.getTypeAtLocation(expression.expression);
    if (function_context_1.getFunctionContextType(context, callerType) === function_context_1.ContextType.Void) {
        throw errors_1.UnsupportedSelfFunctionConversion(node);
    }
    const signature = context.checker.getResolvedSignature(node);
    const params = call_1.transformArguments(context, node.arguments, signature);
    const caller = context.transformExpression(expression.expression);
    const expressionName = expression.name.text;
    switch (expressionName) {
        case "apply":
            return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.FunctionApply, node, caller, ...params);
        case "bind":
            return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.FunctionBind, node, caller, ...params);
        case "call":
            return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.FunctionCall, node, caller, ...params);
        default:
            throw errors_1.UnsupportedProperty("function", expressionName, node);
    }
}
exports.transformFunctionPrototypeCall = transformFunctionPrototypeCall;
//# sourceMappingURL=function.js.map
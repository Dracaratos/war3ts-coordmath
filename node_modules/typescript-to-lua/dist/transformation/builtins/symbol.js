"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lua = require("../../LuaAST");
const errors_1 = require("../utils/errors");
const lualib_1 = require("../utils/lualib");
const call_1 = require("../visitors/call");
// Transpile a Symbol._ property
function transformSymbolConstructorCall(context, expression) {
    const method = expression.expression;
    const signature = context.checker.getResolvedSignature(expression);
    const parameters = call_1.transformArguments(context, expression.arguments, signature);
    const methodName = method.name.text;
    switch (methodName) {
        case "for":
        case "keyFor":
            lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.SymbolRegistry);
            const upperMethodName = methodName[0].toUpperCase() + methodName.slice(1);
            const functionIdentifier = lua.createIdentifier(`__TS__SymbolRegistry${upperMethodName}`);
            return lua.createCallExpression(functionIdentifier, parameters, expression);
        default:
            throw errors_1.UnsupportedProperty("Symbol", methodName, expression);
    }
}
exports.transformSymbolConstructorCall = transformSymbolConstructorCall;
//# sourceMappingURL=symbol.js.map
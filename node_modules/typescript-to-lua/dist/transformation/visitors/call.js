"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../LuaAST");
const builtins_1 = require("../builtins");
const annotations_1 = require("../utils/annotations");
const assignment_validation_1 = require("../utils/assignment-validation");
const errors_1 = require("../utils/errors");
const function_context_1 = require("../utils/function-context");
const lua_ast_1 = require("../utils/lua-ast");
const lualib_1 = require("../utils/lualib");
const safe_names_1 = require("../utils/safe-names");
const typescript_1 = require("../utils/typescript");
const access_1 = require("./access");
const identifier_1 = require("./identifier");
const lua_table_1 = require("./lua-table");
function transformArguments(context, params, signature, callContext) {
    const parameters = params.map(param => context.transformExpression(param));
    // Add context as first param if present
    if (callContext) {
        parameters.unshift(context.transformExpression(callContext));
    }
    if (signature && signature.parameters.length >= params.length) {
        for (const [index, param] of params.entries()) {
            const signatureParameter = signature.parameters[index];
            const paramType = context.checker.getTypeAtLocation(param);
            const signatureType = context.checker.getTypeAtLocation(signatureParameter.valueDeclaration);
            assignment_validation_1.validateAssignment(context, param, paramType, signatureType, signatureParameter.name);
        }
    }
    return parameters;
}
exports.transformArguments = transformArguments;
function transformContextualCallExpression(context, node, transformedArguments) {
    const left = ts.isCallExpression(node) ? node.expression : node.tag;
    if (ts.isPropertyAccessExpression(left) &&
        !safe_names_1.luaKeywords.has(left.name.text) &&
        safe_names_1.isValidLuaIdentifier(left.name.text)) {
        // table:name()
        const table = context.transformExpression(left.expression);
        return lua.createMethodCallExpression(table, identifier_1.transformIdentifier(context, left.name), transformedArguments, node);
    }
    else if (ts.isElementAccessExpression(left) || ts.isPropertyAccessExpression(left)) {
        const callContext = context.transformExpression(left.expression);
        if (typescript_1.isExpressionWithEvaluationEffect(left.expression)) {
            // Inject context parameter
            transformedArguments.unshift(lua.createIdentifier("____self"));
            // Cache left-side if it has effects
            //(function() local ____self = context; return ____self[argument](parameters); end)()
            const argument = ts.isElementAccessExpression(left)
                ? access_1.transformElementAccessArgument(context, left)
                : lua.createStringLiteral(left.name.text);
            const selfIdentifier = lua.createIdentifier("____self");
            const selfAssignment = lua.createVariableDeclarationStatement(selfIdentifier, callContext);
            const index = lua.createTableIndexExpression(selfIdentifier, argument);
            const callExpression = lua.createCallExpression(index, transformedArguments);
            return lua_ast_1.createImmediatelyInvokedFunctionExpression([selfAssignment], callExpression, node);
        }
        else {
            const expression = context.transformExpression(left);
            return lua.createCallExpression(expression, [callContext, ...transformedArguments]);
        }
    }
    else if (ts.isIdentifier(left)) {
        const callContext = context.isStrict ? lua.createNilLiteral() : lua.createIdentifier("_G");
        transformedArguments.unshift(callContext);
        const expression = context.transformExpression(left);
        return lua.createCallExpression(expression, transformedArguments, node);
    }
    else {
        throw errors_1.UnsupportedKind("Left Hand Side Call Expression", left.kind, left);
    }
}
exports.transformContextualCallExpression = transformContextualCallExpression;
function transformPropertyCall(context, node) {
    const signature = context.checker.getResolvedSignature(node);
    if (node.expression.expression.kind === ts.SyntaxKind.SuperKeyword) {
        // Super calls take the format of super.call(self,...)
        const parameters = transformArguments(context, node.arguments, signature, ts.createThis());
        return lua.createCallExpression(context.transformExpression(node.expression), parameters);
    }
    const parameters = transformArguments(context, node.arguments, signature);
    const signatureDeclaration = signature && signature.getDeclaration();
    if (!signatureDeclaration || function_context_1.getDeclarationContextType(context, signatureDeclaration) !== function_context_1.ContextType.Void) {
        // table:name()
        return transformContextualCallExpression(context, node, parameters);
    }
    else {
        const table = context.transformExpression(node.expression.expression);
        // table.name()
        const name = node.expression.name.text;
        const callPath = lua.createTableIndexExpression(table, lua.createStringLiteral(name), node.expression);
        return lua.createCallExpression(callPath, parameters, node);
    }
}
function transformElementCall(context, node) {
    const signature = context.checker.getResolvedSignature(node);
    const signatureDeclaration = signature && signature.getDeclaration();
    const parameters = transformArguments(context, node.arguments, signature);
    if (!signatureDeclaration || function_context_1.getDeclarationContextType(context, signatureDeclaration) !== function_context_1.ContextType.Void) {
        // A contextual parameter must be given to this call expression
        return transformContextualCallExpression(context, node, parameters);
    }
    else {
        // No context
        const expression = context.transformExpression(node.expression);
        return lua.createCallExpression(expression, parameters);
    }
}
exports.transformCallExpression = (node, context) => {
    const luaTableResult = lua_table_1.transformLuaTableCallExpression(context, node);
    if (luaTableResult) {
        return luaTableResult;
    }
    const isTupleReturn = annotations_1.isTupleReturnCall(context, node);
    const isTupleReturnForward = node.parent && ts.isReturnStatement(node.parent) && annotations_1.isInTupleReturnFunction(context, node);
    const isInSpread = node.parent && ts.isSpreadElement(node.parent);
    const returnValueIsUsed = node.parent && !ts.isExpressionStatement(node.parent);
    const wrapResult = isTupleReturn && !isTupleReturnForward && !typescript_1.isInDestructingAssignment(node) && !isInSpread && returnValueIsUsed;
    const builtinResult = builtins_1.transformBuiltinCallExpression(context, node);
    if (builtinResult) {
        return wrapResult ? lua_ast_1.wrapInTable(builtinResult) : builtinResult;
    }
    if (ts.isPropertyAccessExpression(node.expression)) {
        const result = transformPropertyCall(context, node);
        return wrapResult ? lua_ast_1.wrapInTable(result) : result;
    }
    if (ts.isElementAccessExpression(node.expression)) {
        const result = transformElementCall(context, node);
        return wrapResult ? lua_ast_1.wrapInTable(result) : result;
    }
    const signature = context.checker.getResolvedSignature(node);
    // Handle super calls properly
    if (node.expression.kind === ts.SyntaxKind.SuperKeyword) {
        const parameters = transformArguments(context, node.arguments, signature, ts.createThis());
        return lua.createCallExpression(lua.createTableIndexExpression(context.transformExpression(ts.createSuper()), lua.createStringLiteral("____constructor")), parameters);
    }
    const callPath = context.transformExpression(node.expression);
    const signatureDeclaration = signature && signature.getDeclaration();
    let parameters = [];
    if (signatureDeclaration && function_context_1.getDeclarationContextType(context, signatureDeclaration) === function_context_1.ContextType.Void) {
        parameters = transformArguments(context, node.arguments, signature);
    }
    else {
        const callContext = context.isStrict ? ts.createNull() : ts.createIdentifier("_G");
        parameters = transformArguments(context, node.arguments, signature, callContext);
    }
    const callExpression = lua.createCallExpression(callPath, parameters, node);
    return wrapResult ? lua_ast_1.wrapInTable(callExpression) : callExpression;
};
// TODO: Currently it's also used as an array member
exports.transformSpreadElement = (node, context) => {
    const innerExpression = context.transformExpression(node.expression);
    if (annotations_1.isTupleReturnCall(context, node.expression)) {
        return innerExpression;
    }
    if (ts.isIdentifier(node.expression) && annotations_1.isVarArgType(context, node.expression)) {
        return lua.createDotsLiteral(node);
    }
    const type = context.checker.getTypeAtLocation(node.expression);
    if (typescript_1.isArrayType(context, type)) {
        return lua_ast_1.createUnpackCall(context, innerExpression, node);
    }
    return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Spread, node, innerExpression);
};
//# sourceMappingURL=call.js.map
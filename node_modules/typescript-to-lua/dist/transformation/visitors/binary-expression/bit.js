"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const CompilerOptions_1 = require("../../../CompilerOptions");
const lua = require("../../../LuaAST");
const errors_1 = require("../../utils/errors");
const binary_expression_1 = require("../binary-expression");
function transformBinaryBitLibOperation(node, left, right, operator, lib) {
    let bitFunction;
    switch (operator) {
        case ts.SyntaxKind.AmpersandToken:
            bitFunction = "band";
            break;
        case ts.SyntaxKind.BarToken:
            bitFunction = "bor";
            break;
        case ts.SyntaxKind.CaretToken:
            bitFunction = "bxor";
            break;
        case ts.SyntaxKind.LessThanLessThanToken:
            bitFunction = "lshift";
            break;
        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
            bitFunction = "rshift";
            break;
        case ts.SyntaxKind.GreaterThanGreaterThanToken:
            bitFunction = "arshift";
            break;
        default:
            throw errors_1.UnsupportedKind("binary bitwise operator", operator, node);
    }
    return lua.createCallExpression(lua.createTableIndexExpression(lua.createIdentifier(lib), lua.createStringLiteral(bitFunction)), [left, right], node);
}
function transformBinaryBitOperation(context, node, left, right, operator) {
    switch (context.luaTarget) {
        case CompilerOptions_1.LuaTarget.Lua51:
            throw errors_1.UnsupportedForTarget("Bitwise operations", CompilerOptions_1.LuaTarget.Lua51, node);
        case CompilerOptions_1.LuaTarget.Lua52:
            return transformBinaryBitLibOperation(node, left, right, operator, "bit32");
        case CompilerOptions_1.LuaTarget.LuaJIT:
            return transformBinaryBitLibOperation(node, left, right, operator, "bit");
        default:
            const luaOperator = binary_expression_1.transformBinaryOperator(context, node, operator);
            return lua.createBinaryExpression(left, right, luaOperator, node);
    }
}
exports.transformBinaryBitOperation = transformBinaryBitOperation;
function transformUnaryBitLibOperation(node, expression, operator, lib) {
    let bitFunction;
    switch (operator) {
        case lua.SyntaxKind.BitwiseNotOperator:
            bitFunction = "bnot";
            break;
        default:
            throw errors_1.UnsupportedKind("unary bitwise operator", operator, node);
    }
    return lua.createCallExpression(lua.createTableIndexExpression(lua.createIdentifier(lib), lua.createStringLiteral(bitFunction)), [expression], node);
}
function transformUnaryBitOperation(context, node, expression, operator) {
    switch (context.luaTarget) {
        case CompilerOptions_1.LuaTarget.Lua51:
            throw errors_1.UnsupportedForTarget("Bitwise operations", CompilerOptions_1.LuaTarget.Lua51, node);
        case CompilerOptions_1.LuaTarget.Lua52:
            return transformUnaryBitLibOperation(node, expression, operator, "bit32");
        case CompilerOptions_1.LuaTarget.LuaJIT:
            return transformUnaryBitLibOperation(node, expression, operator, "bit");
        default:
            return lua.createUnaryExpression(expression, operator, node);
    }
}
exports.transformUnaryBitOperation = transformUnaryBitOperation;
//# sourceMappingURL=bit.js.map
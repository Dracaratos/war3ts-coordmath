"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../../LuaAST");
const annotations_1 = require("../../utils/annotations");
const errors_1 = require("../../utils/errors");
const lua_ast_1 = require("../../utils/lua-ast");
const lualib_1 = require("../../utils/lualib");
const typescript_1 = require("../../utils/typescript");
const typeof_1 = require("../typeof");
const assignments_1 = require("./assignments");
const bit_1 = require("./bit");
const compound_1 = require("./compound");
function transformBinaryOperator(context, node, operator) {
    switch (operator) {
        // Bitwise operators
        case ts.SyntaxKind.BarToken:
            return lua.SyntaxKind.BitwiseOrOperator;
        case ts.SyntaxKind.CaretToken:
            return lua.SyntaxKind.BitwiseExclusiveOrOperator;
        case ts.SyntaxKind.AmpersandToken:
            return lua.SyntaxKind.BitwiseAndOperator;
        case ts.SyntaxKind.LessThanLessThanToken:
            return lua.SyntaxKind.BitwiseLeftShiftOperator;
        case ts.SyntaxKind.GreaterThanGreaterThanToken:
            throw errors_1.UnsupportedKind("right shift operator (use >>> instead)", operator, node);
        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
            return lua.SyntaxKind.BitwiseRightShiftOperator;
        // Regular operators
        case ts.SyntaxKind.AmpersandAmpersandToken:
            return lua.SyntaxKind.AndOperator;
        case ts.SyntaxKind.BarBarToken:
            return lua.SyntaxKind.OrOperator;
        case ts.SyntaxKind.MinusToken:
            return lua.SyntaxKind.SubtractionOperator;
        case ts.SyntaxKind.PlusToken:
            if (ts.isBinaryExpression(node)) {
                // Check is we need to use string concat operator
                const typeLeft = context.checker.getTypeAtLocation(node.left);
                const typeRight = context.checker.getTypeAtLocation(node.right);
                if (typescript_1.isStringType(context, typeLeft) || typescript_1.isStringType(context, typeRight)) {
                    return lua.SyntaxKind.ConcatOperator;
                }
            }
            return lua.SyntaxKind.AdditionOperator;
        case ts.SyntaxKind.AsteriskToken:
            return lua.SyntaxKind.MultiplicationOperator;
        case ts.SyntaxKind.AsteriskAsteriskToken:
            return lua.SyntaxKind.PowerOperator;
        case ts.SyntaxKind.SlashToken:
            return lua.SyntaxKind.DivisionOperator;
        case ts.SyntaxKind.PercentToken:
            return lua.SyntaxKind.ModuloOperator;
        case ts.SyntaxKind.GreaterThanToken:
            return lua.SyntaxKind.GreaterThanOperator;
        case ts.SyntaxKind.GreaterThanEqualsToken:
            return lua.SyntaxKind.GreaterEqualOperator;
        case ts.SyntaxKind.LessThanToken:
            return lua.SyntaxKind.LessThanOperator;
        case ts.SyntaxKind.LessThanEqualsToken:
            return lua.SyntaxKind.LessEqualOperator;
        case ts.SyntaxKind.EqualsEqualsToken:
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
            return lua.SyntaxKind.EqualityOperator;
        case ts.SyntaxKind.ExclamationEqualsToken:
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
            return lua.SyntaxKind.InequalityOperator;
        default:
            throw errors_1.UnsupportedKind("binary operator", operator, node);
    }
}
exports.transformBinaryOperator = transformBinaryOperator;
function transformBinaryOperation(context, left, right, operator, tsOriginal) {
    switch (operator) {
        case ts.SyntaxKind.AmpersandToken:
        case ts.SyntaxKind.BarToken:
        case ts.SyntaxKind.CaretToken:
        case ts.SyntaxKind.LessThanLessThanToken:
        case ts.SyntaxKind.GreaterThanGreaterThanToken:
        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
            return bit_1.transformBinaryBitOperation(context, tsOriginal, left, right, operator);
        default:
            const luaOperator = transformBinaryOperator(context, tsOriginal, operator);
            if (luaOperator === lua.SyntaxKind.ConcatOperator) {
                left = lua_ast_1.wrapInToStringForConcat(left);
                right = lua_ast_1.wrapInToStringForConcat(right);
            }
            return lua.createBinaryExpression(left, right, luaOperator, tsOriginal);
    }
}
exports.transformBinaryOperation = transformBinaryOperation;
exports.transformBinaryExpression = (node, context) => {
    const typeOfResult = typeof_1.transformTypeOfBinaryExpression(context, node);
    if (typeOfResult) {
        return typeOfResult;
    }
    const operator = node.operatorToken.kind;
    // Check if this is an assignment token, then handle accordingly
    if (compound_1.isCompoundAssignmentToken(operator)) {
        return compound_1.transformCompoundAssignmentExpression(context, node, node.left, node.right, compound_1.unwrapCompoundAssignmentToken(operator), false);
    }
    // Transpile operators
    switch (operator) {
        case ts.SyntaxKind.AmpersandToken:
        case ts.SyntaxKind.BarToken:
        case ts.SyntaxKind.CaretToken:
        case ts.SyntaxKind.LessThanLessThanToken:
        case ts.SyntaxKind.GreaterThanGreaterThanToken:
        case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
        case ts.SyntaxKind.PlusToken:
        case ts.SyntaxKind.AmpersandAmpersandToken:
        case ts.SyntaxKind.BarBarToken:
        case ts.SyntaxKind.MinusToken:
        case ts.SyntaxKind.AsteriskToken:
        case ts.SyntaxKind.AsteriskAsteriskToken:
        case ts.SyntaxKind.SlashToken:
        case ts.SyntaxKind.PercentToken:
        case ts.SyntaxKind.GreaterThanToken:
        case ts.SyntaxKind.GreaterThanEqualsToken:
        case ts.SyntaxKind.LessThanToken:
        case ts.SyntaxKind.LessThanEqualsToken:
        case ts.SyntaxKind.EqualsEqualsToken:
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
        case ts.SyntaxKind.ExclamationEqualsToken:
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
            return transformBinaryOperation(context, context.transformExpression(node.left), context.transformExpression(node.right), operator, node);
        case ts.SyntaxKind.EqualsToken:
            return assignments_1.transformAssignmentExpression(context, node);
        case ts.SyntaxKind.InKeyword: {
            const lhs = context.transformExpression(node.left);
            const rhs = context.transformExpression(node.right);
            const indexExpression = lua.createTableIndexExpression(rhs, lhs);
            return lua.createBinaryExpression(indexExpression, lua.createNilLiteral(), lua.SyntaxKind.InequalityOperator, node);
        }
        case ts.SyntaxKind.InstanceOfKeyword: {
            const lhs = context.transformExpression(node.left);
            const rhs = context.transformExpression(node.right);
            const rhsType = context.checker.getTypeAtLocation(node.right);
            const annotations = annotations_1.getTypeAnnotations(rhsType);
            if (annotations.has(annotations_1.AnnotationKind.Extension) || annotations.has(annotations_1.AnnotationKind.MetaExtension)) {
                // Cannot use instanceof on extension classes
                throw errors_1.InvalidInstanceOfExtension(node);
            }
            if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
                throw errors_1.InvalidInstanceOfLuaTable(node);
            }
            if (typescript_1.isStandardLibraryType(context, rhsType, "ObjectConstructor")) {
                return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.InstanceOfObject, node, lhs);
            }
            return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.InstanceOf, node, lhs, rhs);
        }
        case ts.SyntaxKind.CommaToken: {
            const rhs = context.transformExpression(node.right);
            return lua_ast_1.createImmediatelyInvokedFunctionExpression(context.transformStatements(ts.createExpressionStatement(node.left)), rhs, node);
        }
        default:
            throw errors_1.UnsupportedKind("binary operator", operator, node);
    }
};
function transformBinaryExpressionStatement(context, node) {
    const { expression } = node;
    if (ts.isBinaryExpression(expression)) {
        const operator = expression.operatorToken.kind;
        if (compound_1.isCompoundAssignmentToken(operator)) {
            // +=, -=, etc...
            return compound_1.transformCompoundAssignmentStatement(context, expression, expression.left, expression.right, compound_1.unwrapCompoundAssignmentToken(operator));
        }
        else if (operator === ts.SyntaxKind.EqualsToken) {
            return assignments_1.transformAssignmentStatement(context, expression);
        }
        else if (operator === ts.SyntaxKind.CommaToken) {
            const statements = [
                ...context.transformStatements(ts.createExpressionStatement(expression.left)),
                ...context.transformStatements(ts.createExpressionStatement(expression.right)),
            ];
            return lua.createDoStatement(statements, expression);
        }
    }
}
exports.transformBinaryExpressionStatement = transformBinaryExpressionStatement;
//# sourceMappingURL=index.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../LuaAST");
const builtins_1 = require("../builtins");
const annotations_1 = require("../utils/annotations");
const errors_1 = require("../utils/errors");
const export_1 = require("../utils/export");
const safe_names_1 = require("../utils/safe-names");
const symbols_1 = require("../utils/symbols");
const typescript_1 = require("../utils/typescript");
function transformIdentifier(context, identifier) {
    if (annotations_1.isForRangeType(context, identifier)) {
        const callExpression = typescript_1.findFirstNodeAbove(identifier, ts.isCallExpression);
        if (!callExpression || !callExpression.parent || !ts.isForOfStatement(callExpression.parent)) {
            throw errors_1.InvalidForRangeCall(identifier, "@forRange function can only be used as an iterable in a for...of loop.");
        }
    }
    const text = safe_names_1.hasUnsafeIdentifierName(context, identifier) ? safe_names_1.createSafeName(identifier.text) : identifier.text;
    const symbolId = symbols_1.getIdentifierSymbolId(context, identifier);
    return lua.createIdentifier(text, identifier, symbolId, identifier.text);
}
exports.transformIdentifier = transformIdentifier;
exports.transformIdentifierExpression = (node, context) => {
    // TODO: Move below to avoid extra transforms?
    const identifier = transformIdentifier(context, node);
    const exportScope = export_1.getIdentifierExportScope(context, identifier);
    if (exportScope) {
        return export_1.createExportedIdentifier(context, identifier, exportScope);
    }
    if (node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {
        return lua.createNilLiteral();
    }
    const builtinResult = builtins_1.transformBuiltinIdentifierExpression(context, node);
    if (builtinResult) {
        return builtinResult;
    }
    return identifier;
};
//# sourceMappingURL=identifier.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../../LuaAST");
const errors_1 = require("../../utils/errors");
const export_1 = require("../../utils/export");
const lua_ast_1 = require("../../utils/lua-ast");
const lualib_1 = require("../../utils/lualib");
const accessors_1 = require("./members/accessors");
const utils_1 = require("./utils");
function createClassSetup(context, statement, className, localClassName, classNameText, extendsType) {
    const result = [];
    // __TS__Class()
    const classInitializer = lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Class, statement);
    const defaultExportLeftHandSide = export_1.hasDefaultExportModifier(statement)
        ? lua.createTableIndexExpression(lua_ast_1.createExportsIdentifier(), export_1.createDefaultExportStringLiteral(statement))
        : undefined;
    // [____exports.]className = __TS__Class()
    if (defaultExportLeftHandSide) {
        result.push(lua.createAssignmentStatement(defaultExportLeftHandSide, classInitializer, statement));
    }
    else {
        result.push(...lua_ast_1.createLocalOrExportedOrGlobalDeclaration(context, className, classInitializer, statement));
    }
    if (defaultExportLeftHandSide) {
        // local localClassName = ____exports.default
        result.push(lua.createVariableDeclarationStatement(localClassName, defaultExportLeftHandSide));
    }
    else {
        const exportScope = export_1.getIdentifierExportScope(context, className);
        if (exportScope) {
            // local localClassName = ____exports.className
            result.push(lua.createVariableDeclarationStatement(localClassName, export_1.createExportedIdentifier(context, lua.cloneIdentifier(className), exportScope)));
        }
    }
    // localClassName.name = className
    result.push(lua.createAssignmentStatement(lua.createTableIndexExpression(lua.cloneIdentifier(localClassName), lua.createStringLiteral("name")), lua.createStringLiteral(classNameText), statement));
    // localClassName.____getters = {}
    if (statement.members.some(m => ts.isGetAccessor(m) && utils_1.isStaticNode(m))) {
        const classGetters = lua.createTableIndexExpression(lua.cloneIdentifier(localClassName), lua.createStringLiteral("____getters"));
        const assignClassGetters = lua.createAssignmentStatement(classGetters, lua.createTableExpression(), statement);
        result.push(assignClassGetters);
        lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.ClassIndex);
    }
    // localClassName.____setters = {}
    if (statement.members.some(m => ts.isSetAccessor(m) && utils_1.isStaticNode(m))) {
        const classSetters = lua.createTableIndexExpression(lua.cloneIdentifier(localClassName), lua.createStringLiteral("____setters"));
        const assignClassSetters = lua.createAssignmentStatement(classSetters, lua.createTableExpression(), statement);
        result.push(assignClassSetters);
        lualib_1.importLuaLibFeature(context, lualib_1.LuaLibFeature.ClassNewIndex);
    }
    // localClassName.prototype
    const createClassPrototype = () => lua.createTableIndexExpression(lua.cloneIdentifier(localClassName), lua.createStringLiteral("prototype"));
    // localClassName.prototype.____getters = {}
    if (statement.members.some(m => ts.isGetAccessor(m) && !utils_1.isStaticNode(m))) {
        const classPrototypeGetters = lua.createTableIndexExpression(createClassPrototype(), lua.createStringLiteral("____getters"));
        const assignClassPrototypeGetters = lua.createAssignmentStatement(classPrototypeGetters, lua.createTableExpression(), statement);
        result.push(assignClassPrototypeGetters);
    }
    if (accessors_1.hasMemberInClassOrAncestor(context, statement, m => ts.isGetAccessor(m) && !utils_1.isStaticNode(m))) {
        // localClassName.prototype.__index = __TS__Index(localClassName.prototype)
        const classPrototypeIndex = lua.createTableIndexExpression(createClassPrototype(), lua.createStringLiteral("__index"));
        const assignClassPrototypeIndex = lua.createAssignmentStatement(classPrototypeIndex, lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Index, undefined, createClassPrototype()), statement);
        result.push(assignClassPrototypeIndex);
    }
    if (statement.members.some(m => ts.isSetAccessor(m) && !utils_1.isStaticNode(m))) {
        // localClassName.prototype.____setters = {}
        const classPrototypeSetters = lua.createTableIndexExpression(createClassPrototype(), lua.createStringLiteral("____setters"));
        const assignClassPrototypeSetters = lua.createAssignmentStatement(classPrototypeSetters, lua.createTableExpression(), statement);
        result.push(assignClassPrototypeSetters);
    }
    if (accessors_1.hasMemberInClassOrAncestor(context, statement, m => ts.isSetAccessor(m) && !utils_1.isStaticNode(m))) {
        // localClassName.prototype.__newindex = __TS__NewIndex(localClassName.prototype)
        const classPrototypeNewIndex = lua.createTableIndexExpression(createClassPrototype(), lua.createStringLiteral("__newindex"));
        const assignClassPrototypeIndex = lua.createAssignmentStatement(classPrototypeNewIndex, lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.NewIndex, undefined, createClassPrototype()), statement);
        result.push(assignClassPrototypeIndex);
    }
    const hasStaticGetters = accessors_1.hasMemberInClassOrAncestor(context, statement, m => ts.isGetAccessor(m) && utils_1.isStaticNode(m));
    const hasStaticSetters = accessors_1.hasMemberInClassOrAncestor(context, statement, m => ts.isSetAccessor(m) && utils_1.isStaticNode(m));
    if (extendsType) {
        const extendedTypeNode = utils_1.getExtendedTypeNode(context, statement);
        if (extendedTypeNode === undefined) {
            throw errors_1.UndefinedTypeNode(statement);
        }
        // localClassName.____super = extendsExpression
        const createClassBase = () => lua.createTableIndexExpression(lua.cloneIdentifier(localClassName), lua.createStringLiteral("____super"));
        const assignClassBase = lua.createAssignmentStatement(createClassBase(), context.transformExpression(extendedTypeNode.expression), extendedTypeNode.expression);
        result.push(assignClassBase);
        if (hasStaticGetters || hasStaticSetters) {
            const metatableFields = [];
            if (hasStaticGetters) {
                // __index = __TS__ClassIndex
                metatableFields.push(lua.createTableFieldExpression(lua.createIdentifier("__TS__ClassIndex"), lua.createStringLiteral("__index"), extendedTypeNode.expression));
            }
            else {
                // __index = localClassName.____super
                metatableFields.push(lua.createTableFieldExpression(createClassBase(), lua.createStringLiteral("__index"), extendedTypeNode.expression));
            }
            if (hasStaticSetters) {
                // __newindex = __TS__ClassNewIndex
                metatableFields.push(lua.createTableFieldExpression(lua.createIdentifier("__TS__ClassNewIndex"), lua.createStringLiteral("__newindex"), extendedTypeNode.expression));
            }
            const setClassMetatable = lua.createExpressionStatement(lua.createCallExpression(lua.createIdentifier("setmetatable"), [lua.cloneIdentifier(localClassName), lua.createTableExpression(metatableFields)], extendedTypeNode.expression));
            result.push(setClassMetatable);
        }
        else {
            // setmetatable(localClassName, localClassName.____super)
            const setClassMetatable = lua.createExpressionStatement(lua.createCallExpression(lua.createIdentifier("setmetatable"), [lua.cloneIdentifier(localClassName), createClassBase()], extendedTypeNode.expression));
            result.push(setClassMetatable);
        }
        // setmetatable(localClassName.prototype, localClassName.____super.prototype)
        const basePrototype = lua.createTableIndexExpression(createClassBase(), lua.createStringLiteral("prototype"));
        const setClassPrototypeMetatable = lua.createExpressionStatement(lua.createCallExpression(lua.createIdentifier("setmetatable"), [createClassPrototype(), basePrototype]), extendedTypeNode.expression);
        result.push(setClassPrototypeMetatable);
    }
    else if (hasStaticGetters || hasStaticSetters) {
        const metatableFields = [];
        if (hasStaticGetters) {
            // __index = __TS__ClassIndex
            metatableFields.push(lua.createTableFieldExpression(lua.createIdentifier("__TS__ClassIndex"), lua.createStringLiteral("__index"), statement));
        }
        if (hasStaticSetters) {
            // __newindex = __TS__ClassNewIndex
            metatableFields.push(lua.createTableFieldExpression(lua.createIdentifier("__TS__ClassNewIndex"), lua.createStringLiteral("__newindex"), statement));
        }
        const setClassMetatable = lua.createExpressionStatement(lua.createCallExpression(lua.createIdentifier("setmetatable"), [
            lua.cloneIdentifier(localClassName),
            lua.createTableExpression(metatableFields),
        ]), statement);
        result.push(setClassMetatable);
    }
    return result;
}
exports.createClassSetup = createClassSetup;
//# sourceMappingURL=setup.js.map
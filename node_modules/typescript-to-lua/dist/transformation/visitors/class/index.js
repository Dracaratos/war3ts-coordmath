"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../../LuaAST");
const utils_1 = require("../../../utils");
const annotations_1 = require("../../utils/annotations");
const errors_1 = require("../../utils/errors");
const export_1 = require("../../utils/export");
const lua_ast_1 = require("../../utils/lua-ast");
const safe_names_1 = require("../../utils/safe-names");
const scope_1 = require("../../utils/scope");
const typescript_1 = require("../../utils/typescript");
const identifier_1 = require("../identifier");
const literal_1 = require("../literal");
const decorators_1 = require("./decorators");
const accessors_1 = require("./members/accessors");
const constructor_1 = require("./members/constructor");
const fields_1 = require("./members/fields");
const method_1 = require("./members/method");
const new_1 = require("./new");
const setup_1 = require("./setup");
const utils_2 = require("./utils");
function transformClassAsExpression(expression, context, isDefaultExport = false) {
    let className;
    if (expression.name) {
        className = identifier_1.transformIdentifier(context, expression.name);
    }
    else if (isDefaultExport) {
        className = export_1.createDefaultExportIdentifier(expression);
    }
    else {
        className = lua.createAnonymousIdentifier();
    }
    scope_1.pushScope(context, scope_1.ScopeType.Function);
    const classDeclaration = lua_ast_1.unwrapVisitorResult(transformClassDeclaration(expression, context, className));
    scope_1.popScope(context);
    return lua_ast_1.createImmediatelyInvokedFunctionExpression(classDeclaration, className, expression);
}
exports.transformClassAsExpression = transformClassAsExpression;
const classStacks = new WeakMap();
function transformClassDeclaration(classDeclaration, context, nameOverride) {
    const classStack = utils_1.getOrUpdate(classStacks, context, () => []);
    classStack.push(classDeclaration);
    let className;
    let classNameText;
    if (nameOverride !== undefined) {
        className = nameOverride;
        classNameText = nameOverride.text;
    }
    else if (classDeclaration.name !== undefined) {
        className = identifier_1.transformIdentifier(context, classDeclaration.name);
        classNameText = classDeclaration.name.text;
    }
    else if (export_1.hasDefaultExportModifier(classDeclaration)) {
        const left = export_1.createExportedIdentifier(context, export_1.createDefaultExportIdentifier(classDeclaration));
        const right = transformClassAsExpression(classDeclaration, context, true);
        return lua.createAssignmentStatement(left, right, classDeclaration);
    }
    else {
        throw errors_1.MissingClassName(classDeclaration);
    }
    const annotations = annotations_1.getTypeAnnotations(context.checker.getTypeAtLocation(classDeclaration));
    // Find out if this class is extension of existing class
    const extensionDirective = annotations.get(annotations_1.AnnotationKind.Extension);
    const isExtension = extensionDirective !== undefined;
    const isMetaExtension = annotations.has(annotations_1.AnnotationKind.MetaExtension);
    if (isExtension && isMetaExtension) {
        throw errors_1.InvalidExtensionMetaExtension(classDeclaration);
    }
    if ((isExtension || isMetaExtension) && export_1.getIdentifierExportScope(context, className) !== undefined) {
        // Cannot export extension classes
        throw errors_1.InvalidExportsExtension(classDeclaration);
    }
    // Get type that is extended
    const extendsType = utils_2.getExtendedType(context, classDeclaration);
    if (extendsType) {
        new_1.checkForLuaLibType(context, extendsType);
    }
    if (!(isExtension || isMetaExtension) && extendsType) {
        // Non-extensions cannot extend extension classes
        const extendsAnnotations = annotations_1.getTypeAnnotations(extendsType);
        if (extendsAnnotations.has(annotations_1.AnnotationKind.Extension) || extendsAnnotations.has(annotations_1.AnnotationKind.MetaExtension)) {
            throw errors_1.InvalidExtendsExtension(classDeclaration);
        }
    }
    // You cannot extend LuaTable classes
    if (extendsType) {
        const annotations = annotations_1.getTypeAnnotations(extendsType);
        if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
            throw errors_1.InvalidExtendsLuaTable(classDeclaration);
        }
    }
    // LuaTable classes must be ambient
    if (annotations.has(annotations_1.AnnotationKind.LuaTable) && !typescript_1.isAmbientNode(classDeclaration)) {
        throw errors_1.ForbiddenLuaTableNonDeclaration(classDeclaration);
    }
    // Get all properties with value
    const properties = classDeclaration.members.filter(ts.isPropertyDeclaration).filter(member => member.initializer);
    // Divide properties into static and non-static
    const staticFields = properties.filter(utils_2.isStaticNode);
    const instanceFields = properties.filter(prop => !utils_2.isStaticNode(prop));
    const result = [];
    // Overwrite the original className with the class we are overriding for extensions
    if (isMetaExtension) {
        if (!extendsType) {
            throw errors_1.MissingMetaExtension(classDeclaration);
        }
        const extendsName = lua.createStringLiteral(extendsType.symbol.name);
        className = lua.createIdentifier("__meta__" + extendsName.value);
        // local className = debug.getregistry()["extendsName"]
        const assignDebugCallIndex = lua.createVariableDeclarationStatement(className, lua.createTableIndexExpression(lua.createCallExpression(lua.createTableIndexExpression(lua.createIdentifier("debug"), lua.createStringLiteral("getregistry")), []), extendsName), classDeclaration);
        result.push(assignDebugCallIndex);
    }
    if (extensionDirective !== undefined) {
        const [extensionName] = extensionDirective.args;
        if (extensionName) {
            className = lua.createIdentifier(extensionName);
        }
        else if (extendsType) {
            className = lua.createIdentifier(extendsType.symbol.name);
        }
    }
    let localClassName;
    if (safe_names_1.isUnsafeName(className.text)) {
        localClassName = lua.createIdentifier(safe_names_1.createSafeName(className.text), undefined, className.symbolId, className.text);
        lua.setNodePosition(localClassName, className);
    }
    else {
        localClassName = className;
    }
    if (!isExtension && !isMetaExtension) {
        result.push(...setup_1.createClassSetup(context, classDeclaration, className, localClassName, classNameText, extendsType));
    }
    else {
        for (const f of instanceFields) {
            const fieldName = literal_1.transformPropertyName(context, f.name);
            const value = f.initializer !== undefined ? context.transformExpression(f.initializer) : undefined;
            // className["fieldName"]
            const classField = lua.createTableIndexExpression(lua.cloneIdentifier(className), fieldName);
            // className["fieldName"] = value;
            const assignClassField = lua.createAssignmentStatement(classField, value);
            result.push(assignClassField);
        }
    }
    // Find first constructor with body
    if (!isExtension && !isMetaExtension) {
        const constructor = classDeclaration.members.find((n) => ts.isConstructorDeclaration(n) && n.body !== undefined);
        if (constructor) {
            // Add constructor plus initialization of instance fields
            const constructorResult = constructor_1.transformConstructorDeclaration(context, constructor, localClassName, instanceFields, classDeclaration);
            if (constructorResult)
                result.push(constructorResult);
        }
        else if (!extendsType) {
            // Generate a constructor if none was defined in a base class
            const constructorResult = constructor_1.transformConstructorDeclaration(context, ts.createConstructor([], [], [], ts.createBlock([], true)), localClassName, instanceFields, classDeclaration);
            if (constructorResult)
                result.push(constructorResult);
        }
        else if (instanceFields.length > 0 ||
            classDeclaration.members.some(m => accessors_1.isGetAccessorOverride(context, m, classDeclaration))) {
            // Generate a constructor if none was defined in a class with instance fields that need initialization
            // localClassName.prototype.____constructor = function(self, ...)
            //     baseClassName.prototype.____constructor(self, ...)
            //     ...
            const constructorBody = fields_1.transformClassInstanceFields(context, classDeclaration, instanceFields);
            const superCall = lua.createExpressionStatement(lua.createCallExpression(lua.createTableIndexExpression(context.transformExpression(ts.createSuper()), lua.createStringLiteral("____constructor")), [lua_ast_1.createSelfIdentifier(), lua.createDotsLiteral()]));
            constructorBody.unshift(superCall);
            const constructorFunction = lua.createFunctionExpression(lua.createBlock(constructorBody), [lua_ast_1.createSelfIdentifier()], lua.createDotsLiteral(), undefined, lua.FunctionExpressionFlags.Declaration);
            result.push(lua.createAssignmentStatement(constructor_1.createConstructorName(localClassName), constructorFunction, classDeclaration));
        }
    }
    // Transform accessors
    result.push(...classDeclaration.members
        .filter(ts.isAccessor)
        .map(accessor => accessors_1.transformAccessorDeclaration(context, accessor, localClassName))
        .filter(utils_1.isNonNull));
    // Transform methods
    result.push(...classDeclaration.members
        .filter(ts.isMethodDeclaration)
        .map(m => method_1.transformMethodDeclaration(context, m, localClassName, isExtension || isMetaExtension))
        .filter(utils_1.isNonNull));
    // Add static declarations
    for (const field of staticFields) {
        const fieldName = literal_1.transformPropertyName(context, field.name);
        const value = field.initializer ? context.transformExpression(field.initializer) : undefined;
        const classField = lua.createTableIndexExpression(lua.cloneIdentifier(localClassName), fieldName);
        const fieldAssign = lua.createAssignmentStatement(classField, value);
        result.push(fieldAssign);
    }
    const decorationStatement = decorators_1.createConstructorDecorationStatement(context, classDeclaration);
    if (decorationStatement) {
        result.push(decorationStatement);
    }
    classStack.pop();
    return result;
}
exports.transformClassDeclaration = transformClassDeclaration;
exports.transformSuperExpression = (expression, context) => {
    const classStack = utils_1.getOrUpdate(classStacks, context, () => []);
    const classDeclaration = classStack[classStack.length - 1];
    const typeNode = utils_2.getExtendedTypeNode(context, classDeclaration);
    if (typeNode === undefined) {
        throw errors_1.UnknownSuperType(expression);
    }
    const extendsExpression = typeNode.expression;
    let baseClassName;
    if (ts.isIdentifier(extendsExpression)) {
        const symbol = context.checker.getSymbolAtLocation(extendsExpression);
        if (symbol && !export_1.isSymbolExported(context, symbol)) {
            // Use "baseClassName" if base is a simple identifier
            baseClassName = identifier_1.transformIdentifier(context, extendsExpression);
        }
    }
    if (!baseClassName) {
        if (classDeclaration.name === undefined) {
            throw errors_1.MissingClassName(expression);
        }
        // Use "className.____super" if the base is not a simple identifier
        baseClassName = lua.createTableIndexExpression(identifier_1.transformIdentifier(context, classDeclaration.name), lua.createStringLiteral("____super"), expression);
    }
    return lua.createTableIndexExpression(baseClassName, lua.createStringLiteral("prototype"));
};
exports.transformThisExpression = node => lua_ast_1.createSelfIdentifier(node);
//# sourceMappingURL=index.js.map
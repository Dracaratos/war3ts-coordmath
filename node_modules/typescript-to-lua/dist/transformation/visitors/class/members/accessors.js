"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../../../LuaAST");
const lua_ast_1 = require("../../../utils/lua-ast");
const function_1 = require("../../function");
const identifier_1 = require("../../identifier");
const utils_1 = require("../utils");
// TODO: Inline to `hasMemberInClassOrAncestor`?
function* classWithAncestors(context, classDeclaration) {
    yield classDeclaration;
    const extendsType = utils_1.getExtendedType(context, classDeclaration);
    if (!extendsType) {
        return false;
    }
    const symbol = extendsType.getSymbol();
    if (symbol === undefined) {
        return false;
    }
    const symbolDeclarations = symbol.getDeclarations();
    if (symbolDeclarations === undefined) {
        return false;
    }
    const declaration = symbolDeclarations.find(ts.isClassLike);
    if (!declaration) {
        return false;
    }
    yield* classWithAncestors(context, declaration);
}
exports.hasMemberInClassOrAncestor = (context, classDeclaration, callback) => [...classWithAncestors(context, classDeclaration)].some(c => c.members.some(callback));
function getPropertyName(propertyName) {
    if (ts.isIdentifier(propertyName) || ts.isStringLiteral(propertyName) || ts.isNumericLiteral(propertyName)) {
        return propertyName.text;
    }
    else {
        return undefined; // TODO: how to handle computed property names?
    }
}
function isSamePropertyName(a, b) {
    const aName = getPropertyName(a);
    const bName = getPropertyName(b);
    return aName !== undefined && aName === bName;
}
function isGetAccessorOverride(context, element, classDeclaration) {
    if (!ts.isGetAccessor(element) || utils_1.isStaticNode(element)) {
        return false;
    }
    return exports.hasMemberInClassOrAncestor(context, classDeclaration, m => ts.isPropertyDeclaration(m) && m.initializer !== undefined && isSamePropertyName(m.name, element.name));
}
exports.isGetAccessorOverride = isGetAccessorOverride;
function transformAccessorDeclaration(context, node, className) {
    if (node.body === undefined) {
        return undefined;
    }
    const name = identifier_1.transformIdentifier(context, node.name);
    const [params, dot, restParam] = function_1.transformParameters(context, node.parameters, lua_ast_1.createSelfIdentifier());
    const [body] = function_1.transformFunctionBody(context, node.parameters, node.body, restParam);
    const accessorFunction = lua.createFunctionExpression(lua.createBlock(body), params, dot, restParam, lua.FunctionExpressionFlags.Declaration);
    const methodTable = utils_1.isStaticNode(node)
        ? lua.cloneIdentifier(className)
        : lua.createTableIndexExpression(lua.cloneIdentifier(className), lua.createStringLiteral("prototype"));
    const classAccessorsName = ts.isGetAccessorDeclaration(node) ? "____getters" : "____setters";
    const classAccessors = lua.createTableIndexExpression(methodTable, lua.createStringLiteral(classAccessorsName));
    const accessorPath = lua.createTableIndexExpression(classAccessors, lua.createStringLiteral(name.text));
    return lua.createAssignmentStatement(accessorPath, accessorFunction, node);
}
exports.transformAccessorDeclaration = transformAccessorDeclaration;
//# sourceMappingURL=accessors.js.map
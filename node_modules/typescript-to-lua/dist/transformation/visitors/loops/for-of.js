"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../../LuaAST");
const utils_1 = require("../../../utils");
const annotations_1 = require("../../utils/annotations");
const errors_1 = require("../../utils/errors");
const lua_ast_1 = require("../../utils/lua-ast");
const lualib_1 = require("../../utils/lualib");
const typescript_1 = require("../../utils/typescript");
const call_1 = require("../call");
const identifier_1 = require("../identifier");
const variable_declaration_1 = require("../variable-declaration");
const utils_2 = require("./utils");
function transformForOfInitializer(context, initializer, expression) {
    if (ts.isVariableDeclarationList(initializer)) {
        const binding = utils_2.getVariableDeclarationBinding(initializer);
        // Declaration of new variable
        if (ts.isArrayBindingPattern(binding)) {
            if (binding.elements.length === 0) {
                // Ignore empty destructuring assignment
                return [];
            }
            return variable_declaration_1.transformBindingPattern(context, binding, expression);
        }
        else if (ts.isObjectBindingPattern(binding)) {
            throw errors_1.UnsupportedObjectDestructuringInForOf(initializer);
        }
        const variableStatements = variable_declaration_1.transformVariableDeclaration(context, initializer.declarations[0]);
        if (variableStatements[0]) {
            // we can safely assume that for vars are not exported and therefore declarationstatenents
            return [
                lua.createVariableDeclarationStatement(variableStatements[0].left, expression),
            ];
        }
        else {
            throw errors_1.MissingForOfVariables(initializer);
        }
    }
    else {
        // Assignment to existing variable
        let variables;
        let valueExpression = expression;
        if (ts.isArrayLiteralExpression(initializer)) {
            if (initializer.elements.length > 0) {
                valueExpression = lua_ast_1.createUnpackCall(context, expression, initializer);
                variables = utils_1.castEach(initializer.elements.map(e => context.transformExpression(e)), lua.isAssignmentLeftHandSideExpression);
            }
            else {
                // Ignore empty destructring assignment
                return [];
            }
        }
        else if (ts.isObjectLiteralExpression(initializer)) {
            throw errors_1.UnsupportedObjectDestructuringInForOf(initializer);
        }
        else {
            variables = utils_1.cast(context.transformExpression(initializer), lua.isAssignmentLeftHandSideExpression);
        }
        return [lua.createAssignmentStatement(variables, valueExpression)];
    }
}
function transformForRangeStatement(context, statement, block) {
    if (!ts.isCallExpression(statement.expression)) {
        throw errors_1.InvalidForRangeCall(statement.expression, "Expression must be a call expression.");
    }
    if (statement.expression.arguments.length < 2 || statement.expression.arguments.length > 3) {
        throw errors_1.InvalidForRangeCall(statement.expression, "@forRange function must take 2 or 3 arguments.");
    }
    if (statement.expression.arguments.some(a => !typescript_1.isNumberType(context, context.checker.getTypeAtLocation(a)))) {
        throw errors_1.InvalidForRangeCall(statement.expression, "@forRange arguments must be number types.");
    }
    if (!ts.isVariableDeclarationList(statement.initializer)) {
        throw errors_1.InvalidForRangeCall(statement.initializer, "@forRange loop must declare its own control variable.");
    }
    const binding = utils_2.getVariableDeclarationBinding(statement.initializer);
    if (!ts.isIdentifier(binding)) {
        throw errors_1.InvalidForRangeCall(statement.initializer, "@forRange loop cannot use destructuring.");
    }
    if (!typescript_1.isNumberType(context, context.checker.getTypeAtLocation(binding))) {
        throw errors_1.InvalidForRangeCall(statement.expression, "@forRange function must return Iterable<number> or Array<number>.");
    }
    const control = identifier_1.transformIdentifier(context, binding);
    const signature = context.checker.getResolvedSignature(statement.expression);
    const [start, limit, step] = call_1.transformArguments(context, statement.expression.arguments, signature);
    return lua.createForStatement(block, control, start, limit, step, statement);
}
function transformForOfLuaIteratorStatement(context, statement, block) {
    const luaIterator = context.transformExpression(statement.expression);
    const type = context.checker.getTypeAtLocation(statement.expression);
    const tupleReturn = annotations_1.getTypeAnnotations(type).has(annotations_1.AnnotationKind.TupleReturn);
    if (tupleReturn) {
        // LuaIterator + TupleReturn
        if (ts.isVariableDeclarationList(statement.initializer)) {
            // Variables declared in for loop
            // for ${initializer} in ${iterable} do
            const binding = utils_2.getVariableDeclarationBinding(statement.initializer);
            if (ts.isArrayBindingPattern(binding)) {
                const identifiers = binding.elements.map(e => variable_declaration_1.transformArrayBindingElement(context, e));
                if (identifiers.length === 0) {
                    identifiers.push(lua.createAnonymousIdentifier());
                }
                return lua.createForInStatement(block, identifiers, [luaIterator]);
            }
            else {
                // Single variable is not allowed
                throw errors_1.UnsupportedNonDestructuringLuaIterator(statement.initializer);
            }
        }
        else {
            // Variables NOT declared in for loop - catch iterator values in temps and assign
            // for ____value0 in ${iterable} do
            //     ${initializer} = ____value0
            if (ts.isArrayLiteralExpression(statement.initializer)) {
                const tmps = statement.initializer.elements.map((_, i) => lua.createIdentifier(`____value${i}`));
                if (tmps.length > 0) {
                    const assign = lua.createAssignmentStatement(utils_1.castEach(statement.initializer.elements.map(e => context.transformExpression(e)), lua.isAssignmentLeftHandSideExpression), tmps);
                    block.statements.splice(0, 0, assign);
                }
                else {
                    tmps.push(lua.createAnonymousIdentifier());
                }
                return lua.createForInStatement(block, tmps, [luaIterator]);
            }
            else {
                // Single variable is not allowed
                throw errors_1.UnsupportedNonDestructuringLuaIterator(statement.initializer);
            }
        }
    }
    else {
        // LuaIterator (no TupleReturn)
        if (ts.isVariableDeclarationList(statement.initializer) &&
            statement.initializer.declarations.length > 0 &&
            ts.isIdentifier(statement.initializer.declarations[0].name)) {
            // Single variable declared in for loop
            // for ${initializer} in ${iterator} do
            return lua.createForInStatement(block, [identifier_1.transformIdentifier(context, statement.initializer.declarations[0].name)], [luaIterator]);
        }
        else {
            // Destructuring or variable NOT declared in for loop
            // for ____value in ${iterator} do
            //     local ${initializer} = unpack(____value)
            const valueVariable = lua.createIdentifier("____value");
            const initializer = transformForOfInitializer(context, statement.initializer, valueVariable);
            if (initializer) {
                block.statements.splice(0, 0, ...initializer);
            }
            return lua.createForInStatement(block, [valueVariable], [luaIterator]);
        }
    }
}
function transformForOfArrayStatement(context, statement, block) {
    let valueVariable;
    if (ts.isVariableDeclarationList(statement.initializer)) {
        // Declaration of new variable
        const binding = utils_2.getVariableDeclarationBinding(statement.initializer);
        if (ts.isArrayBindingPattern(binding) || ts.isObjectBindingPattern(binding)) {
            valueVariable = lua.createIdentifier("____values");
            const initializer = transformForOfInitializer(context, statement.initializer, valueVariable);
            if (initializer) {
                block.statements.unshift(...initializer);
            }
        }
        else {
            valueVariable = identifier_1.transformIdentifier(context, binding);
        }
    }
    else {
        // Assignment to existing variable
        valueVariable = lua.createIdentifier("____value");
        const initializer = transformForOfInitializer(context, statement.initializer, valueVariable);
        if (initializer) {
            block.statements.unshift(...initializer);
        }
    }
    const ipairsCall = lua.createCallExpression(lua.createIdentifier("ipairs"), [
        context.transformExpression(statement.expression),
    ]);
    return lua.createForInStatement(block, [lua.createAnonymousIdentifier(), valueVariable], [ipairsCall], statement);
}
function transformForOfIteratorStatement(context, statement, block) {
    const iterable = context.transformExpression(statement.expression);
    if (ts.isVariableDeclarationList(statement.initializer) &&
        statement.initializer.declarations.length > 0 &&
        ts.isIdentifier(statement.initializer.declarations[0].name)) {
        // Single variable declared in for loop
        // for ${initializer} in __TS__iterator(${iterator}) do
        return lua.createForInStatement(block, [identifier_1.transformIdentifier(context, statement.initializer.declarations[0].name)], [lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Iterator, statement.expression, iterable)]);
    }
    else {
        // Destructuring or variable NOT declared in for loop
        // for ____value in __TS__iterator(${iterator}) do
        //     local ${initializer} = ____value
        const valueVariable = lua.createIdentifier("____value");
        const initializer = transformForOfInitializer(context, statement.initializer, valueVariable);
        if (initializer) {
            block.statements.unshift(...initializer);
        }
        return lua.createForInStatement(block, [valueVariable], [lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Iterator, statement.expression, iterable)]);
    }
}
exports.transformForOfStatement = (node, context) => {
    const body = lua.createBlock(utils_2.transformLoopBody(context, node));
    if (ts.isCallExpression(node.expression) && annotations_1.isForRangeType(context, node.expression.expression)) {
        return transformForRangeStatement(context, node, body);
    }
    else if (annotations_1.isLuaIteratorType(context, node.expression)) {
        return transformForOfLuaIteratorStatement(context, node, body);
    }
    else if (typescript_1.isArrayType(context, context.checker.getTypeAtLocation(node.expression))) {
        return transformForOfArrayStatement(context, node, body);
    }
    else {
        return transformForOfIteratorStatement(context, node, body);
    }
};
//# sourceMappingURL=for-of.js.map
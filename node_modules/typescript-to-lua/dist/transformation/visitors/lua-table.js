"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../LuaAST");
const annotations_1 = require("../utils/annotations");
const errors_1 = require("../utils/errors");
const call_1 = require("./call");
function parseLuaTableExpression(context, node) {
    if (ts.isPropertyAccessExpression(node)) {
        return [context.transformExpression(node.expression), node.name.text];
    }
    else {
        throw errors_1.UnsupportedKind("LuaTable access expression", node.kind, node);
    }
}
function validateLuaTableCall(methodName, callArguments, original) {
    if (callArguments.some(argument => ts.isSpreadElement(argument))) {
        throw errors_1.ForbiddenLuaTableUseException("Arguments cannot be spread.", original);
    }
    switch (methodName) {
        case "get":
            if (callArguments.length !== 1) {
                throw errors_1.ForbiddenLuaTableUseException("One parameter is required for get().", original);
            }
            break;
        case "set":
            if (callArguments.length !== 2) {
                throw errors_1.ForbiddenLuaTableUseException("Two parameters are required for set().", original);
            }
            break;
    }
}
function transformLuaTableExpressionAsExpressionStatement(context, expression) {
    const [luaTable, methodName] = parseLuaTableExpression(context, expression.expression);
    validateLuaTableCall(methodName, expression.arguments, expression);
    const signature = context.checker.getResolvedSignature(expression);
    const params = call_1.transformArguments(context, expression.arguments, signature);
    switch (methodName) {
        case "get":
            return lua.createVariableDeclarationStatement(lua.createAnonymousIdentifier(expression), lua.createTableIndexExpression(luaTable, params[0], expression), expression);
        case "set":
            return lua.createAssignmentStatement(lua.createTableIndexExpression(luaTable, params[0], expression), params.splice(1), expression);
        default:
            throw errors_1.UnsupportedProperty("LuaTable", methodName, expression);
    }
}
function transformLuaTableExpressionStatement(context, node) {
    const expression = ts.isExpressionStatement(node) ? node.expression : node;
    if (ts.isCallExpression(expression) && ts.isPropertyAccessExpression(expression.expression)) {
        const ownerType = context.checker.getTypeAtLocation(expression.expression.expression);
        const annotations = annotations_1.getTypeAnnotations(ownerType);
        if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
            return transformLuaTableExpressionAsExpressionStatement(context, expression);
        }
    }
}
exports.transformLuaTableExpressionStatement = transformLuaTableExpressionStatement;
function transformLuaTableCallExpression(context, node) {
    if (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression)) {
        const ownerType = context.checker.getTypeAtLocation(node.expression.expression);
        const annotations = annotations_1.getTypeAnnotations(ownerType);
        if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
            const [luaTable, methodName] = parseLuaTableExpression(context, node.expression);
            validateLuaTableCall(methodName, node.arguments, node);
            const signature = context.checker.getResolvedSignature(node);
            const params = call_1.transformArguments(context, node.arguments, signature);
            switch (methodName) {
                case "get":
                    return lua.createTableIndexExpression(luaTable, params[0], node);
                default:
                    throw errors_1.UnsupportedProperty("LuaTable", methodName, node);
            }
        }
    }
}
exports.transformLuaTableCallExpression = transformLuaTableCallExpression;
function transformLuaTablePropertyAccessExpression(context, node) {
    const type = context.checker.getTypeAtLocation(node.expression);
    const annotations = annotations_1.getTypeAnnotations(type);
    if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
        const [luaTable, propertyName] = parseLuaTableExpression(context, node);
        switch (node.name.text) {
            case "length":
                return lua.createUnaryExpression(luaTable, lua.SyntaxKind.LengthOperator, node);
            default:
                throw errors_1.UnsupportedProperty("LuaTable", propertyName, node);
        }
    }
}
exports.transformLuaTablePropertyAccessExpression = transformLuaTablePropertyAccessExpression;
function transformLuaTableElementAccessExpression(context, node) {
    const annotations = annotations_1.getTypeAnnotations(context.checker.getTypeAtLocation(node.expression));
    if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
        throw errors_1.UnsupportedKind("LuaTable access expression", node.kind, node);
    }
}
exports.transformLuaTableElementAccessExpression = transformLuaTableElementAccessExpression;
function transformLuaTableNewExpression(context, node) {
    const type = context.checker.getTypeAtLocation(node);
    const annotations = annotations_1.getTypeAnnotations(type);
    if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
        if (node.arguments && node.arguments.length > 0) {
            throw errors_1.ForbiddenLuaTableUseException("No parameters are allowed when constructing a LuaTable object.", node);
        }
        else {
            return lua.createTableExpression();
        }
    }
}
exports.transformLuaTableNewExpression = transformLuaTableNewExpression;
//# sourceMappingURL=lua-table.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../../LuaAST");
const errors_1 = require("../utils/errors");
const export_1 = require("../utils/export");
const lualib_1 = require("../utils/lualib");
const safe_names_1 = require("../utils/safe-names");
const symbols_1 = require("../utils/symbols");
const typescript_1 = require("../utils/typescript");
const function_1 = require("./function");
// TODO: Move to object-literal.ts?
function transformPropertyName(context, node) {
    if (ts.isComputedPropertyName(node)) {
        return context.transformExpression(node.expression);
    }
    else if (ts.isIdentifier(node)) {
        return lua.createStringLiteral(node.text);
    }
    else {
        return context.transformExpression(node);
    }
}
exports.transformPropertyName = transformPropertyName;
function createShorthandIdentifier(context, valueSymbol, propertyIdentifier) {
    let name;
    if (valueSymbol !== undefined) {
        name = safe_names_1.hasUnsafeSymbolName(context, valueSymbol, propertyIdentifier)
            ? safe_names_1.createSafeName(valueSymbol.name)
            : valueSymbol.name;
    }
    else {
        const propertyName = propertyIdentifier.text;
        if (safe_names_1.luaKeywords.has(propertyName) || !safe_names_1.isValidLuaIdentifier(propertyName)) {
            // Catch ambient declarations of identifiers with bad names
            throw errors_1.InvalidAmbientIdentifierName(propertyIdentifier);
        }
        name = safe_names_1.hasUnsafeIdentifierName(context, propertyIdentifier) ? safe_names_1.createSafeName(propertyName) : propertyName;
    }
    let identifier = context.transformExpression(ts.createIdentifier(name));
    lua.setNodeOriginal(identifier, propertyIdentifier);
    if (valueSymbol !== undefined && lua.isIdentifier(identifier)) {
        identifier.symbolId = symbols_1.getSymbolIdOfSymbol(context, valueSymbol);
        const exportScope = export_1.getSymbolExportScope(context, valueSymbol);
        if (exportScope) {
            identifier = export_1.createExportedIdentifier(context, identifier, exportScope);
        }
    }
    return identifier;
}
exports.createShorthandIdentifier = createShorthandIdentifier;
const transformObjectLiteralExpression = (expression, context) => {
    let properties = [];
    const tableExpressions = [];
    for (const element of expression.properties) {
        const name = element.name ? transformPropertyName(context, element.name) : undefined;
        if (ts.isPropertyAssignment(element)) {
            const expression = context.transformExpression(element.initializer);
            properties.push(lua.createTableFieldExpression(expression, name, element));
        }
        else if (ts.isShorthandPropertyAssignment(element)) {
            const valueSymbol = context.checker.getShorthandAssignmentValueSymbol(element);
            if (valueSymbol) {
                symbols_1.trackSymbolReference(context, valueSymbol, element.name);
            }
            const identifier = createShorthandIdentifier(context, valueSymbol, element.name);
            properties.push(lua.createTableFieldExpression(identifier, name, element));
        }
        else if (ts.isMethodDeclaration(element)) {
            const expression = function_1.transformFunctionLikeDeclaration(element, context);
            properties.push(lua.createTableFieldExpression(expression, name, element));
        }
        else if (ts.isSpreadAssignment(element)) {
            // Create a table for preceding properties to preserve property order
            // { x: 0, ...{ y: 2 }, y: 1, z: 2 } --> __TS__ObjectAssign({x = 0}, {y = 2}, {y = 1, z = 2})
            if (properties.length > 0) {
                const tableExpression = lua.createTableExpression(properties, expression);
                tableExpressions.push(tableExpression);
                properties = [];
            }
            const type = context.checker.getTypeAtLocation(element.expression);
            let tableExpression;
            if (typescript_1.isArrayType(context, type)) {
                tableExpression = lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.ArrayToObject, element.expression, context.transformExpression(element.expression));
            }
            else {
                tableExpression = context.transformExpression(element.expression);
            }
            tableExpressions.push(tableExpression);
        }
        else {
            // TODO: Accessors
            throw errors_1.UnsupportedKind("object literal element", element.kind, expression);
        }
    }
    if (tableExpressions.length === 0) {
        return lua.createTableExpression(properties, expression);
    }
    else {
        if (properties.length > 0) {
            const tableExpression = lua.createTableExpression(properties, expression);
            tableExpressions.push(tableExpression);
        }
        if (tableExpressions[0].kind !== lua.SyntaxKind.TableExpression) {
            tableExpressions.unshift(lua.createTableExpression(undefined, expression));
        }
        return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.ObjectAssign, expression, ...tableExpressions);
    }
};
const transformArrayLiteralExpression = (expression, context) => {
    const values = expression.elements.map(element => lua.createTableFieldExpression(ts.isOmittedExpression(element) ? lua.createNilLiteral(element) : context.transformExpression(element), undefined, element));
    return lua.createTableExpression(values, expression);
};
exports.literalVisitors = {
    [ts.SyntaxKind.NullKeyword]: node => lua.createNilLiteral(node),
    [ts.SyntaxKind.TrueKeyword]: node => lua.createBooleanLiteral(true, node),
    [ts.SyntaxKind.FalseKeyword]: node => lua.createBooleanLiteral(false, node),
    [ts.SyntaxKind.NumericLiteral]: node => lua.createNumericLiteral(Number(node.text), node),
    [ts.SyntaxKind.StringLiteral]: node => lua.createStringLiteral(node.text, node),
    [ts.SyntaxKind.NoSubstitutionTemplateLiteral]: node => lua.createStringLiteral(node.text, node),
    [ts.SyntaxKind.ObjectLiteralExpression]: transformObjectLiteralExpression,
    [ts.SyntaxKind.ArrayLiteralExpression]: transformArrayLiteralExpression,
};
//# sourceMappingURL=literal.js.map
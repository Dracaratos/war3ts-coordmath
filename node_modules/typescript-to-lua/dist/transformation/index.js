"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const lua = require("../LuaAST");
const utils_1 = require("../utils");
const context_1 = require("./context");
const errors_1 = require("./utils/errors");
const lualib_1 = require("./utils/lualib");
const visitors_1 = require("./visitors");
const transpileErrorDiagnostic = (error) => ({
    file: error.node.getSourceFile(),
    start: error.node.getStart(),
    length: error.node.getWidth(),
    category: ts.DiagnosticCategory.Error,
    code: 0,
    source: "typescript-to-lua",
    messageText: error.message,
});
function createVisitorMap(customVisitors) {
    const visitorMap = new Map();
    for (const visitors of [visitors_1.standardVisitors, ...customVisitors]) {
        const priority = visitors === visitors_1.standardVisitors ? -Infinity : 0;
        for (const [syntaxKindKey, visitor] of Object.entries(visitors)) {
            if (!visitor)
                continue;
            const syntaxKind = Number(syntaxKindKey);
            const nodeVisitors = utils_1.getOrUpdate(visitorMap, syntaxKind, () => []);
            const objectVisitor = typeof visitor === "function" ? { transform: visitor, priority } : visitor;
            nodeVisitors.push(objectVisitor);
        }
    }
    for (const nodeVisitors of visitorMap.values()) {
        nodeVisitors.sort((a, b) => { var _a, _b; return (_a = a.priority, (_a !== null && _a !== void 0 ? _a : 0)) - (_b = b.priority, (_b !== null && _b !== void 0 ? _b : 0)); });
    }
    return visitorMap;
}
exports.createVisitorMap = createVisitorMap;
function transformSourceFile(program, sourceFile, visitorMap) {
    const context = new context_1.TransformationContext(program, sourceFile, visitorMap);
    try {
        const [luaAst] = context.transformNode(sourceFile);
        const luaLibFeatures = lualib_1.getUsedLuaLibFeatures(context);
        return { luaAst, luaLibFeatures, diagnostics: [] };
    }
    catch (error) {
        if (!(error instanceof errors_1.TranspileError))
            throw error;
        return {
            luaAst: lua.createBlock([
                lua.createExpressionStatement(lua.createCallExpression(lua.createIdentifier("error"), [lua.createStringLiteral(error.message)])),
            ]),
            luaLibFeatures: new Set(),
            diagnostics: [transpileErrorDiagnostic(error)],
        };
    }
}
exports.transformSourceFile = transformSourceFile;
//# sourceMappingURL=index.js.map
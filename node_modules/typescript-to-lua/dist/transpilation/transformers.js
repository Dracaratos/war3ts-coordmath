"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const resolve = require("resolve");
const ts = require("typescript");
// TODO: Don't depend on CLI?
const cliDiagnostics = require("../cli/diagnostics");
const diagnosticFactories = require("./diagnostics");
exports.noImplicitSelfTransformer = () => node => {
    const transformSourceFile = node => {
        const empty = ts.createNotEmittedStatement(undefined);
        ts.addSyntheticLeadingComment(empty, ts.SyntaxKind.MultiLineCommentTrivia, "* @noSelfInFile ", true);
        return ts.updateSourceFileNode(node, [empty, ...node.statements], node.isDeclarationFile);
    };
    return ts.isBundle(node)
        ? ts.updateBundle(node, node.sourceFiles.map(transformSourceFile))
        : transformSourceFile(node);
};
function getCustomTransformers(program, diagnostics, customTransformers, onSourceFile) {
    var _a, _b, _c, _d, _e, _f;
    const luaTransformer = () => sourceFile => {
        onSourceFile(sourceFile);
        return ts.createSourceFile(sourceFile.fileName, "", ts.ScriptTarget.ESNext);
    };
    const transformersFromOptions = loadTransformersFromOptions(program, diagnostics);
    const afterDeclarations = [
        ...(_a = transformersFromOptions.afterDeclarations, (_a !== null && _a !== void 0 ? _a : [])),
        ...(_b = customTransformers.afterDeclarations, (_b !== null && _b !== void 0 ? _b : [])),
    ];
    const options = program.getCompilerOptions();
    if (options.noImplicitSelf) {
        afterDeclarations.unshift(exports.noImplicitSelfTransformer);
    }
    return {
        afterDeclarations,
        before: [
            ...(_c = customTransformers.before, (_c !== null && _c !== void 0 ? _c : [])),
            ...(_d = transformersFromOptions.before, (_d !== null && _d !== void 0 ? _d : [])),
            ...(_e = transformersFromOptions.after, (_e !== null && _e !== void 0 ? _e : [])),
            ...(_f = customTransformers.after, (_f !== null && _f !== void 0 ? _f : [])),
            luaTransformer,
        ],
    };
}
exports.getCustomTransformers = getCustomTransformers;
function loadTransformersFromOptions(program, allDiagnostics) {
    const customTransformers = {
        before: [],
        after: [],
        afterDeclarations: [],
    };
    const options = program.getCompilerOptions();
    if (!options.plugins)
        return customTransformers;
    const configFileName = options.configFilePath;
    const basedir = configFileName ? path.dirname(configFileName) : process.cwd();
    for (const [index, transformerImport] of options.plugins.entries()) {
        if (!("transform" in transformerImport))
            continue;
        const optionName = `compilerOptions.plugins[${index}]`;
        const { error: resolveError, factory } = resolveTransformerFactory(basedir, optionName, transformerImport);
        if (resolveError)
            allDiagnostics.push(resolveError);
        if (factory === undefined)
            continue;
        const { error: loadError, transformer } = loadTransformer(optionName, program, factory, transformerImport);
        if (loadError)
            allDiagnostics.push(loadError);
        if (transformer === undefined)
            continue;
        if (transformer.before) {
            customTransformers.before.push(transformer.before);
        }
        if (transformer.after) {
            customTransformers.after.push(transformer.after);
        }
        if (transformer.afterDeclarations) {
            customTransformers.afterDeclarations.push(transformer.afterDeclarations);
        }
    }
    return customTransformers;
}
function resolveTransformerFactory(basedir, transformerOptionPath, { transform, import: importName = "default" }) {
    if (typeof transform !== "string") {
        const optionName = `${transformerOptionPath}.transform`;
        return { error: cliDiagnostics.compilerOptionRequiresAValueOfType(optionName, "string") };
    }
    let resolved;
    try {
        resolved = resolve.sync(transform, { basedir, extensions: [".js", ".ts", ".tsx"] });
    }
    catch (err) {
        if (err.code !== "MODULE_NOT_FOUND")
            throw err;
        return { error: diagnosticFactories.couldNotResolveTransformerFrom(transform, basedir) };
    }
    // tslint:disable-next-line: deprecation
    const hasNoRequireHook = require.extensions[".ts"] === undefined;
    if (hasNoRequireHook && (resolved.endsWith(".ts") || resolved.endsWith(".tsx"))) {
        try {
            const tsNode = require("ts-node");
            tsNode.register({ transpileOnly: true });
        }
        catch (err) {
            if (err.code !== "MODULE_NOT_FOUND")
                throw err;
            return { error: diagnosticFactories.toLoadTransformerItShouldBeTranspiled(transform) };
        }
    }
    const factory = require(resolved)[importName];
    if (factory === undefined) {
        return { error: diagnosticFactories.transformerShouldHaveAExport(transform, importName) };
    }
    return { factory };
}
function loadTransformer(transformerOptionPath, program, factory, { transform, after = false, afterDeclarations = false, type = "program", ...extraOptions }) {
    var _a, _b;
    let transformer;
    switch (type) {
        case "program":
            transformer = factory(program, extraOptions);
            break;
        case "config":
            transformer = factory(extraOptions);
            break;
        case "checker":
            transformer = factory(program.getTypeChecker(), extraOptions);
            break;
        case "raw":
            transformer = factory;
            break;
        case "compilerOptions":
            transformer = factory(program.getCompilerOptions(), extraOptions);
            break;
        default: {
            const optionName = `--${transformerOptionPath}.type`;
            return { error: cliDiagnostics.argumentForOptionMustBe(optionName, "program") };
        }
    }
    if (typeof after !== "boolean") {
        const optionName = `${transformerOptionPath}.after`;
        return { error: cliDiagnostics.compilerOptionRequiresAValueOfType(optionName, "boolean") };
    }
    if (typeof afterDeclarations !== "boolean") {
        const optionName = `${transformerOptionPath}.afterDeclarations`;
        return { error: cliDiagnostics.compilerOptionRequiresAValueOfType(optionName, "boolean") };
    }
    if (typeof transformer === "function") {
        let wrappedTransformer;
        if (after) {
            wrappedTransformer = { after: transformer };
        }
        else if (afterDeclarations) {
            wrappedTransformer = { afterDeclarations: transformer };
        }
        else {
            wrappedTransformer = { before: transformer };
        }
        return { transformer: wrappedTransformer };
    }
    else {
        const isValidGroupTransformer = typeof transformer === "object" &&
            (_b = (_a = transformer.before, (_a !== null && _a !== void 0 ? _a : transformer.after)), (_b !== null && _b !== void 0 ? _b : transformer.afterDeclarations)) !== undefined;
        if (!isValidGroupTransformer) {
            return { error: diagnosticFactories.transformerShouldBeATsTransformerFactory(transform) };
        }
    }
    return { transformer };
}
//# sourceMappingURL=transformers.js.map
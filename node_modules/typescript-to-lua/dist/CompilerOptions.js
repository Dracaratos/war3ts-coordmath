"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
var LuaLibImportKind;
(function (LuaLibImportKind) {
    LuaLibImportKind["None"] = "none";
    LuaLibImportKind["Always"] = "always";
    LuaLibImportKind["Inline"] = "inline";
    LuaLibImportKind["Require"] = "require";
})(LuaLibImportKind = exports.LuaLibImportKind || (exports.LuaLibImportKind = {}));
var LuaTarget;
(function (LuaTarget) {
    LuaTarget["Lua51"] = "5.1";
    LuaTarget["Lua52"] = "5.2";
    LuaTarget["Lua53"] = "5.3";
    LuaTarget["LuaJIT"] = "JIT";
})(LuaTarget = exports.LuaTarget || (exports.LuaTarget = {}));
function validateOptions(options) {
    const diagnostics = [];
    if (options.luaBundle && !options.luaBundleEntry) {
        diagnostics.push(configErrorDiagnostic(`'luaBundleEntry' is required when 'luaBundle' is enabled.`));
    }
    if (options.luaBundle && options.luaLibImport === LuaLibImportKind.Inline) {
        diagnostics.push(configWarningDiagnostic(`Using 'luaBundle' with 'luaLibImport: "inline"' might generate duplicate code. ` +
            `It is recommended to use 'luaLibImport: "require"'`));
    }
    return diagnostics;
}
exports.validateOptions = validateOptions;
const configErrorDiagnostic = (message) => ({
    file: undefined,
    start: undefined,
    length: undefined,
    category: ts.DiagnosticCategory.Error,
    code: 0,
    source: "typescript-to-lua",
    messageText: message,
});
const configWarningDiagnostic = (message) => ({
    file: undefined,
    start: undefined,
    length: undefined,
    category: ts.DiagnosticCategory.Warning,
    code: 0,
    source: "typescript-to-lua",
    messageText: message,
});
//# sourceMappingURL=CompilerOptions.js.map